---

### LeapRead - Chrome 插件开发文档

---

### 1. 项目背景与目标
*   **项目名称：** LeapRead - AI Article Summarizer
*   **背景：** 随着信息爆炸，用户阅读长篇公众号文章时常常难以快速获取核心信息。本插件旨在通过AI技术，为用户提供文章的精炼总结，并方便查看文章中的所有外部链接。
*   **目标：** 提供一个轻量级的 Chrome 插件，用户在阅读公众号文章时，点击插件按钮即可快速获取总结和链接列表，提升阅读效率。插件应具备高度的灵活性，允许用户自定义大模型和总结风格。

### 2. 功能概述
插件核心功能：
*   **智能文章总结：** 对当前公众号文章正文进行分析，生成结构化、精炼的Markdown格式总结。
*   **外部链接提取：** 自动识别并列出文章中包含的所有外部超链接。
*   **高度可配置：** 允许用户配置使用不同的大模型API，并选择不同的总结风格（Prompt）。

### 3. 技术栈与架构原则
*   **主要技术栈：** Chrome 扩展 API，JavaScript/TypeScript，HTML/CSS。
*   **架构原则：**
    *   **客户端侧处理：** 所有核心逻辑（HTML 清洗、大模型调用、链接提取）均在 Chrome 插件内部实现，**不依赖外部服务器**。
    *   **简洁可靠：** 优先选择最简单、最主流的实现方式，确保插件的稳定性和性能。
    *   **模块化：** HTML 清洗、链接提取、AI 模型交互等功能应模块化，便于维护和测试。
    *   **可配置性：** 大模型API配置和Prompt配置需通过插件设置界面对用户开放。

### 4. 详细功能需求

#### 4.1 输入处理 - 文章内容抓取与清洗模块

*   **触发机制：** 用户在公众号文章页面（URL 匹配 `https://mp.weixin.qq.com/s/...` 或其他指定公众号文章域名）点击 Chrome 插件的 UI 按钮。
*   **内容抓取：** 插件通过 `content script` 或其他 Chrome API 获取当前页面的完整 HTML DOM。
*   **正文清洗逻辑：** (`AI Coding 实现`)
    *   **目标：** 从完整的 HTML 中提取出公众号文章的核心正文内容，去除所有非正文元素。
    *   **输入：** 包含简单 HTML 标签的公众号文章页面 HTML 片段。公众号页面的HTML结构相对干净，无需处理复杂的广告、评论区等。
    *   **输出：** 用于提交给大模型的纯文本内容。
    *   **具体要求：**
        *   识别并提取文章标题、作者、发布时间（视公众号页面结构而定，如果稳定可提取则保留）。
        *   识别并提取文章主体内容所在的 DOM 元素（通常是特定的 `div` 或 `section`）。
        *   去除：图片（`<img>` 标签）、视频（`<video>` 标签）、音频、二维码、非正文的浮动按钮、公众号关注引导、页脚等元素，仅保留文本信息。
        *   保留：`<a>` 标签以便后续提取链接（见 4.2）。
        *   将清洗后的 HTML 片段转换为纯文本，尽可能保留段落、标题结构（例如，Markdown风格的 `#` 或 `##` 代表标题，空行代表段落）。
        *   **注意：** 确保清洗后的文本不会包含过多的空白字符或无意义的HTML实体。

#### 4.2 链接提取模块

*   **触发机制：** 与 4.1 文章内容抓取后并行或紧随其后。
*   **目标：** 从抓取到的公众号文章正文 HTML 中，精确提取所有外部超链接。
*   **输入：** 清洗前的公众号文章 HTML DOM 片段（包含 `<a>` 标签）。
*   **输出：** 一个包含“链接文案”和“链接地址”的结构化列表。
*   **具体要求：**
    *   遍历所有 `<a>` 标签。
    *   提取 `<a>` 标签内的文本内容作为“链接文案”。
    *   提取 `<a>` 标签的 `href` 属性作为“链接地址”。
    *   过滤掉内部锚点链接（`#...`）和 JavaScript 伪链接（`javascript:void(0)`）。
    *   **示例输出格式：**
        ```json
        [
          {"text": "某个外部网站", "url": "https://www.example.com"},
          {"text": "另一篇文章链接", "url": "https://another.blog/post/123"}
        ]
        ```

#### 4.3 AI 大模型交互模块 (总结功能)

*   **目标：** 封装与大模型 API 的交互逻辑，接收文章文本，返回总结文本。
*   **输入：**
    *   清洗后的文章纯文本 (来自 4.1)。
    *   用户选定的 Prompt 内容 (来自 4.3.2)。
*   **输出：** 大模型返回的总结文本。
*   **具体要求：**

##### 4.3.1 大模型 API 配置 (用户可配置)
*   **用户界面：** 插件应提供一个设置界面，允许用户配置以下信息：
    *   **大模型 API 终结点 (Endpoint URL)：** 允许用户输入不同的 API URL，以支持不同的模型服务商（例如：OpenAI, Gemini, 某个私有部署模型等）。
    *   **API Key：** 允许用户输入和保存对应 API 的鉴权密钥。
    *   **模型名称 (Model Identifier)：** 如果 API 支持多种模型，允许用户指定使用的模型名称（例如：`gpt-4`, `gemini-pro` 等）。
*   **存储：** 所有配置信息应安全存储在 Chrome 插件的 `chrome.storage.local` 中。
*   **默认值：** 插件应提供一个默认的 API 配置（例如，指向 OpenAI 的某个默认模型），方便新用户直接使用。

##### 4.3.2 总结风格选择 (Prompt 可配置)
*   **加载机制：**
    *   **内置 Prompt：** 插件应内置一个默认的 Prompt 模板（我们最终确认的Prompt）。
    *   **用户自定义 Prompt：** 插件提供设置界面，允许用户**选择加载本地文件**作为 Prompt。
        *   **文件格式：** 应支持 Markdown (`.md`) 或纯文本 (`.txt`) 格式的文件，因为 Prompt 通常是文本描述。
        *   **存储：** 用户选择加载的 Prompt 文件内容应被读取并存储在 `chrome.storage.local` 中，以便插件下次启动时仍能使用。
        *   **目录结构：** 这些可加载文件（包括我们的示例Prompt）应与代码文件放在同一路径下，便于 AI Coding 团队管理和用户在本地加载。
        *   **示例 Prompt 组织：** AI Coding 可以创建一个 `prompts/` 文件夹，将预设的 Prompt 文件（例如 `default_summary_prompt.md`）放在其中，并允许用户从该路径或其本地文件系统选择其他 Prompt 文件。
*   **Prompt 内容：** (待我最终整理提供，将作为 `default_summary_prompt.md` 的内容)

##### 4.3.3 API 调用与错误处理
*   **SDK 或 HTTP Request：** 根据用户配置的大模型 API 终结点，选择使用对应的 JS SDK (如果存在) 或直接发起 HTTP `POST` 请求。
*   **鉴权头：** API Key 需正确地作为 `Authorization` 头 (Bearer Token) 或其他指定方式包含在请求中。
*   **请求体：** 将清洗后的文章文本作为 `messages` (聊天模型) 或 `prompt` (补全模型) 的一部分发送。
*   **失败处理：** 当大模型 API 调用失败（网络错误、鉴权失败、模型返回错误、Token 超限等）时，需要捕获异常并向用户提供友好的错误提示。例如：“API 调用失败，请检查网络或您的 API Key 配置。”，并且在控制台输出详细错误信息。

#### 4.4 输出格式与展示

*   **总结内容 (`summary: string`)：**
    *   **格式：** Markdown 无序列表。
    *   **结构：** 允许一级列表和二级列表嵌套。
    *   **样式：** 允许列表中包含粗体（`**text**`）和斜体（`*text*`）等少量 Markdown 格式。
    *   **精简要求：** 总结内容应保持高度精简，去除冗余和营销性质信息。
    *   **个人思考：** 大模型生成的总结中，可以包含类似“个人思考”的部分，但需确保其与原文内容相关且具有启发性，不臆造。
*   **提取链接 (`extracted_links: json array`)：**
    *   **格式：** 之前确认的 JSON 数组，每个元素包含 `{"text": "链接文案", "url": "链接地址"}`。
    *   **展示：** 在插件 UI 中以列表形式展示，文案和链接均可点击跳转。

### 5. 非功能性需求

*   **性能：** 总结和链接提取过程应在合理时间内完成（例如，常规文章在几秒内）。由于所有逻辑在客户端执行，性能受限于浏览器资源和API响应速度。
*   **可靠性：** 插件功能稳定，不易崩溃，且能妥善处理各种错误情况。
*   **安全性：** 用户 API Key 和自定义 Prompt 等敏感信息需安全存储在 `chrome.storage.local` 中，避免在插件代码中硬编码或通过不安全方式传输。
*   **用户体验：** 插件 UI 简洁直观，易于操作。提供必要的加载状态、错误提示和结果展示。
*   **兼容性：** 兼容主流 Chrome 浏览器版本。

### 6. 日志与监控 (初期简化)

*   **初期：** 无需复杂的外部日志与监控系统。
*   **调试与错误报告：** 关键错误信息应通过 `console.error()` 输出，便于开发者调试。API 调用成功与否、Token 消耗等信息可在 `console.log()` 中输出，用于初步的性能评估。
*   **用户反馈：** 考虑提供一个简单的入口，允许用户复制日志或错误信息以便进行反馈。

---

### **最终 Prompt 信息 (待提供)**

最终 Prompt 在 **`default_summary_prompt.md`** 中。